{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/blog/how-internet-is-networked/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Enjeck's Personal Website","author":"Enjeck Cleopatra"}},"mdx":{"id":"cbb232ef-159f-54a5-89dd-a614716d81c5","excerpt":"The Internet is the global system of interconnected computer networks that can communicate with one another. The internet is made of made up of many nodes (orâ€¦","frontmatter":{"title":"How the internet is networked","date":"November 11, 2021"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How the internet is networked\",\n  \"date\": \"2021-11-11\",\n  \"categories\": [\"internet\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The Internet is the global system of interconnected computer networks that can communicate with one another. The internet is made of made up of many nodes (or centers) that are connected directly or indirectly. \"), mdx(\"h3\", null, \"Nodes\"), mdx(\"p\", null, \"Devices on the internet communicate with one another using nodes. A node is a device on a network that can send or recieve information. For example, your phone, computer and the server hosting this website are nodes. Every node on a network has has address, which is used to identify the nodes. On the internet, this network address is called the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"IP Address\"), \". Nodes can communicate with other nodes on the same network using the address of the destination node. For information to reach the right destination node, it often has to pass through intermediate nodes. \"), mdx(\"h3\", null, \"Routers\"), mdx(\"p\", null, \"We can use routers to connect different networks. A \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"router\"), \" is a device that directs information from one network to another. This information is in the form of IP packets, pieces of data that form internet traffic. \"), mdx(\"h3\", null, \"Servers and Clients\"), mdx(\"p\", null, \"A server is a node that provides services over a network. Servers can accept connections from other nodes, and can transmit, receive and process information. Examples of server nodes are email services and website hosts.\"), mdx(\"p\", null, \"A client is a node that uses a service. Examples of clients are user devices like phones, or client applications.\"), mdx(\"p\", null, \"For you to view this web page, your browser had to fetch it from a server. When you read an email, you use a client application (e.g Gmail) to connect with the email server.  \"), mdx(\"h3\", null, \"Types of networks\"), mdx(\"p\", null, \"communicate between networks and devices.\\nNetworks can be classified according to their shapes when mapped out:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Centralized network\"), \": A centralized network is one where many clients are connected through a single router. It is shaped like a star with a central node. An example of a centralized network is a game server that has many player devices connected to it. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Decentralized network\"), \": A decentralized network is one that has many clients connected to several routers that are connected to each other. It is shaped like a constellation of many stars. An example of a decentralized network is an email delivery server. Generally, the internet is structured as a decentralized network. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Distributed network\"), \": It is possible for clients to also act as servers. A distributed network is a network where all nodes are connected to each other, with each node acting as both a client and server. In a fully distributed network, all nodes can communicate directed with each other without any central servers. \")), mdx(\"p\", null, \"Today, a lot of internet services are centralized by big companies. Two disadvantages of this is that the privacy of the internet user is reduced and a single point of failure can result to failures across all dependent websites. Many people hope we can have a decentralized internet someday\"), mdx(\"h3\", null, \"Hardware Addresses\"), mdx(\"p\", null, \"For devices like computers and phones to connect to a network, they need a network card. In addition to connecting a device to a network, the network card provides the hardware address, which is used to identify the device on a network. \"), mdx(\"p\", null, \"The network card of a device on the internet has a MAC (Media Access Control) address (or device ID). This is a unique address a device uses to communicate with other devices, such as a router. The MAC address is only used by local networks, mainly to identify a device, e.g a router uses the address to identify the device connected to it. \"), mdx(\"p\", null, \"The MAC Address of a device can be used to monitor the movement of people in an area. For this reason, some operating systems randomize the MAC address to make is harder to link hardware addresses to real-world devices. \"), mdx(\"h3\", null, \"How a device joins a network (internet)\"), mdx(\"p\", null, \"To connect adevice to the internet, you can use an Ethernet cable, Wi-FI (via a router), mobile network or satellite network. Once connected, your device\\u2019s network card is then given a network address and becomes part of the network. Your device can now send and receive information from other nodes in the network. \"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/blog/how-internet-is-networked/","previous":{"id":"5cde0a4a-0d39-5571-b866-9742d177f053","fields":{"slug":"/blog/javascript-regex/"},"frontmatter":{"title":"JavaScript regular expressions crash course"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"JavaScript regular expressions crash course\",\n  \"date\": \"2021-11-11\",\n  \"categories\": [\"JavaScript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Regular expressions are a method to describe patterns in string data. Regular expressions form a tiny, separate language that is part of many languages, including JavaScript. \"), mdx(\"p\", null, \"They might have a cryptic syntax and often difficult to write, but knowing them is important. Regular expressions are very useful, expectially for processing and inspecting strings. \"), mdx(\"h3\", null, \"Creating a regular expression\"), mdx(\"p\", null, \"In JavaScript, a regular expression is an object, constructed with either the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"RegExp\"), \" constructor or with forward slash (/) characters enclosing a pattern as a literal value. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let regExpres1 = new RegExp(\\\"xyz\\\");\\nlet regExpres2 = /xyz/\\n\")), mdx(\"p\", null, \"Both of the above regular expression objects represent a pattern of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"x\"), \" character followed by a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"b\"), \" character followed by a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"c\"), \". \"), mdx(\"p\", null, \"When creating a regular expression using the RegExp constructor, the pattern is written as a normal string. Here, backslashes can be used as usual.\\nWhereas, regular expressions defined using the literal notation and slash deals with backslashes differently. A forward slash starts and ends the pattern, so we have to place a backslash before any forward slash that we want to be part of the pattern. If a backslash is not part of a special character (such as \\\\n, \\\\t), it is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"preserved\"), \" instead of ignored, since they are in strings and therefore will change the meaning of the pattern. Characters like plus signs (+) and question marks (?) have special meanings in regular expressions and need to be preceded by a backslash if you want to indicate the character itself. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let helloQuestion = /hello\\\\?/\\n\")), mdx(\"p\", null, \"Like \\u201Cnormal\\u201D objects, regular expressions have methods. The most common method is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"test\"), \", which accepts a string and returns a Boolean that tells you whether the string matches the pattern in the expression. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"console.log(/xyz/.test(\\\"abcxyz\\\"));\\n// \\u2192 true\\nconsole.log(/xyz/.test(\\\"axyzbc\\\"));\\n// \\u2192 true\\nconsole.log(/xyz/.test(\\\"uvwxzya\\\"));\\n// \\u2192 false\\n\")), mdx(\"p\", null, \"When there are no special characters, a regular expression of characters represent that sequence of characters. In our example, we are testing if \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"xyz\"), \" occurs anywhere in the string. Granted, this is a simple test which can easily be replicated using indexOf. Regular expressions are not made for such simple cases. Their power lie in their ability to allow us express complex patterns. \"), mdx(\"p\", null, \"Assume we want to match a set of characters, say, any latin letter. In regular expressions, placing a set of characters between square brackets makes that part of the regular expression to match any of the characters within the brackets. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"console.log(/[abcdefghijklmnopqrstuvwxyz]/.test(\\\"year 2021\\\"));\\n// \\u2192 true\\n\")), mdx(\"p\", null, \"The above expression matches all strings that contain lowercase latin letters. We can make the expression shorter by using a hyphen (-). A hyphen between two characters between square brackets represent a range of characters. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"console.log(/[a-z]/.test(\\\"year 2021\\\"));\\n// \\u2192 true\\n\")), mdx(\"p\", null, \"We can test for numbers in a similar way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"console.log(/[0123456789]/.test(\\\"year 2021\\\"));\\n// \\u2192 true\\nconsole.log(/[0-9]/.test(\\\"year 2021\\\"));\\n// \\u2192 true\\n\")), mdx(\"p\", null, \"For a range of characters indicated with a hyphen, the ordering of the characters is determined by their Unicode number. For example, characters \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"a-z\"), \" (codes 97-122) are next to each in the Unicode ordering, and so using range \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[a-z]\"), \" includes every character in this range and matches all lowercase latin letters.\"), mdx(\"p\", null, \"In regular expressions, character sets/groups have built-in shorthand for writing them. Digits, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[0-9]\"), \" can be represented as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\d\"), \". There\\u2019s more:\"), mdx(\"p\", null, \"| \\\\d  | A digit character |\\n| \\\\D  | A character that is not a digit |\\n| \\\\w  | An alphanumeric character (\\u201Cword character\\u201D)|\\n| \\\\W  | A nonalphanumeric character |\\n| \\\\s  | Any whitespace character (space, tab, newline, and similar) |\\n| \\\\S  | Any character except for newline | \"), mdx(\"p\", null, \"If we want to match a phone number with format \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"XXX-XXX-XXXX\"), \", here\\u2019s how we can do it:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let phoneNum = /\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d-\\\\d\\\\d\\\\d\\\\d/\\nconsole.log(phoneNum.test(\\\"202-588-6500\\\"));\\n// \\u2192 true\\nconsole.log(phoneNum.test(\\\"67-500-647\\\"));\\n// \\u2192 false\\n\")), mdx(\"p\", null, \"These shorthand codes can also be used within square brakets to indicate a set of characters. For example, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[\\\\d]\"), \" represents any digit. When special characters like the period (.) and + are used between square brackets, they lose their special meaning. So, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"[.+]\"), \" means any period or plus character. \"), mdx(\"p\", null, \"The caret (^) character lets you invert a set of characters. That is, indicate that you want to match any character except the character(s) in the given set. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let notNumber = /[^\\\\d]/;\\nconsole.log(notNumber.test(\\\"ujdhf345kd\\\"));\\n// \\u2192 true\\nconsole.log(notNumber.test(\\\"3453\\\"));\\n// \\u2192 false\\n\")), mdx(\"p\", null, \"Let\\u2019s revisit out phone number matching code from earlier. The code works. But it looks very clunky and awkward to write. There are too many \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\\d\"), \"\\u2019s, which make it difficult to see the pattern we are trying to represent. To match repeating parts of a pattern, such as a sequence of digits, we use the plus sign (+). The plus sign is used after something in a regular expression to indicate that the element may be repeated more than once. The expression \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"/\\\\d+/\"), \" matches one or more digit characters. So, we can shorten our code like so:\"), mdx(\"p\", null, \"let phoneNum = /\\\\d+-\\\\d+-\\\\d+/\\nconsole.log(phoneNum.test(\\u201C202-588-6500\\u201D));\\n// \\u2192 true\\nconsole.log(phoneNum.test(\\u201C67-500-647\\u201D));\\n// \\u2192 true\"), mdx(\"p\", null, \"The plus symbol lets a pattern to match at least once. To allow a match of zero or more times, we use the asterisk (*). The star does not stop a pattern matching \\u2014 it just matches zero instances if the pattern does not exist. \"), mdx(\"p\", null, \"console.log(/\\u2018\\\\d\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\u2018/.test(\\u201C\\u2018890\\u2019\\u201D));\\n// \\u2192 true\\nconsole.log(/\\u2018\\\\d\"), \"\\u2018/.test(\\u201D\\u201D\\u201D));\\n// \\u2192 true\"), mdx(\"p\", null, \"The previous phone number code is much more concise, but it also matches other formats in addition to the XXX-XXX-XXXX format we expect it to. That\\u2019s because /\\\\d+/ matches any number of digits. \"), mdx(\"p\", null, \"To specify the number of times a pattern should occur, we use numbers within braces after an element. For example, using {3} after an element specifies that the element should occur exactly three times. We can also specify a range by separating two numbers with a comma. {3, 5} indicates that the element should occur at lease thrice and at most five times. When can specify open-ended ranges by not writing a second number after the comma. Thus, {3,} means three or more times. \"), mdx(\"p\", null, \"Here\\u2019s another modification of our phone number verification code:\"), mdx(\"p\", null, \"let phoneNum = /\\\\d{3}-\\\\d{3}-\\\\d{4}/\\nconsole.log(phoneNum.test(\\u201C202-588-6500\\u201D));\\n// \\u2192 true\\nconsole.log(phoneNum.test(\\u201C67-500-647\\u201D));\\n// \\u2192 false\"), mdx(\"p\", null, \"Phone numbers are usually valid even when they are not hyphenated. We can make the hyphen optional. To make a part of a pattern optional, we use the question mark (?). The question allows a character to occur zero or one times. \"), mdx(\"p\", null, \"let phoneNum = /\\\\d{3}-?\\\\d{3}-?\\\\d{4}/\\nconsole.log(phoneNum.test(\\u201C202-588-6500\\u201D));\\n// \\u2192 true\\nconsole.log(phoneNum.test(\\u201C2025886500\\u201D));\\n// \\u2192 true\"), mdx(\"p\", null, \"In the above example, the pattern matches even when the hyphen character (-) is ommitted. \"), mdx(\"p\", null, \"We enclose multiple elements in parentheses () to treat them as a single element when using operators like + or *. When a part of a regular expression is surrounded by parentheses, it is treated as a a single element by any operations following it. \"), mdx(\"p\", null, \"let santaLaugh = /(ho)+/i;\\nconsole.log(santaLaugh.test(\\u201CHohohoho\\u201D));\\n// \\u2192 true\"), mdx(\"p\", null, \"The + applies to the group -ho- and it matches one or more sequences like it. The -i- character at the end of the expression makes the regular expression case insensitive. This ensures that it matches the uppercase H in the input string, despite the fact that the pattern is all lowercase. \"), mdx(\"p\", null, \"Unlike the -test- method that returns only true or false depending on whether or not the pattern matched, the -exec- (execute) method returns an object with information about the match if a match is found and returns -null- otherwise. \"), mdx(\"p\", null, \"let execMatch = /\\\\d+/.exec(\\u201Cabc 123\\u201D);\\nconsole.log(execMatch);\\n// \\u2192 Array \", \"[ \\u201C123\\u201D ]\", \"\\nconsole.log(execMatch.index);\\n// \\u2192 4\"), mdx(\"p\", null, \"let execMatch2 = /\\\\d+/.exec(\\u201Cabc\\u201D);\\nconsole.log(execMatch2);\\n// \\u2192 null\"), mdx(\"p\", null, \"When we log execMatch, we see an array whose first element is a sequence of the successful match. exec has an -index- property that tells us the position where the successful match begins. \"), mdx(\"p\", null, \"The -match- method for strings behaves like -exec-. \"), mdx(\"p\", null, \"console.log(\\u201Cabc 123\\u201D.match(/\\\\d+/));\\n// \\u2192 Array \", \"[ \\u201C123\\u201D ]\"), mdx(\"p\", null, \"If the regular expression has subexpressions within parentheses, any text matching these subexpressions will be shown in the array. The first element of the array is always the whole match. The next element, if it exists, is the part matched by the first subexpression \\u2014 that is, the subexpression whose opening parenthesis appear first in the expression \\u2014 then the second expression, and so on.\"), mdx(\"p\", null, \"let quoted = /\\u2018(\", mdx(\"sup\", {\n    parentName: \"p\",\n    \"id\": \"fnref-'\"\n  }, mdx(\"a\", {\n    parentName: \"sup\",\n    \"href\": \"#fn-'\",\n    \"className\": \"footnote-ref\"\n  }, \"'\")), \"*)\\u2019/\\nconsole.log(quoted.exec(\\u201CI said \\u2018yes\\u2019 to his proposal\\u201D));\\n// \\u2192 Array \", \"[ \\u201C\\u2018yes\\u2019\\u201D, \\u201Cyes\\u201D ]\"), mdx(\"p\", null, \"When a subexpression grouped in parentheses does not have a match in the inut string (for example, when the subexpression is followed by a question mark), the value -undefined- is pu in it\\u2019s position in the output array. \"), mdx(\"p\", null, \"console.log(/program(mer)?/.exec(\\u201Cprogram\\u201D));\\n// \\u2192 Array \", \"[ \\u201Cprogram\\u201D, undefined ]\", \"\\nconsole.log(/(\\\\w)+/.exec(\\u201Cabc\\u201D));\\n// \\u2192 Array \", \"[ \\u201Cabc\\u201D, \\u201Cc\\u201D ]\"), mdx(\"p\", null, \"To make a match span through an entire string, we use the ^ and $ characters. The dollar sign matches the end of the input string, while the caret matches the start. The expression /^\\\\d+\", mdx(\"span\", {\n    parentName: \"p\",\n    \"className\": \"math math-inline\"\n  }, \"/ matches a string that is made up of numbers from start to end. /^a/ matches a string that starts with the letter a, and /!\"), \"/ matches a string that ends with an exclamation mark. \"), mdx(\"p\", null, \"The marker \\\\b refers to a word boundary, which can be the start or end of the string. It can also refer to any place in the string that has a word character on one side and nonword character on the other side. \"), mdx(\"p\", null, \"console.log(/pp/.test(\\u201Chappy\\u201D));\\n// \\u2192 true\\nconsole.log(/\\\\bpp\\\\b/.test(\\u201Chappy\\u201D));\\n// \\u2192 false\"), mdx(\"p\", null, \"A boundary marker makes a regular expression to match only when a specific condition holds at the point it exists in the pattern. It does not match an actual character. \"), mdx(\"p\", null, \"We use the pipe character (|) indicates a choice between a pattern to its left and that to its right. For example, we can match a text that contains the word \\u201Cwatch\\u201D in either its plural (ending with \\u201Ces\\u201D) form, past tense (ending with \\u201Ced\\u201D) or personal noun (ending with \\u201Cer\\u201D) form. \"), mdx(\"p\", null, \"let word = /\\\\b\\\\watch(es|ed|er)?\\\\b/;\\nconsole.log(word.test(\\u201Cwatch\\u201D));\\n// \\u2192 true\\nconsole.log(word.test(\\u201Cwatched\\u201D));\\n// \\u2192 true\\nconsole.log(word.test(\\u201Cwatcherrr\\u201D));\\n// \\u2192 false\"), mdx(\"p\", null, \"In the example, we use parentheses to limit the section of the expression that the pipe operator should be applied to. \"), mdx(\"p\", null, \"The replace method can be used on strings to replace part of a string with another string. For example:\"), mdx(\"p\", null, \"console.log(\\u201Chaha\\u201D.replace(\\u201Ca\\u201D, \\u201Ce\\u201D));\\n// \\u2192 heha\"), mdx(\"p\", null, \"It is possible to set the first argument of the replace method to be a regular expressions. Here, the first match of the regular expression is replaced. To replace all matches in a string rather than just the first, add the -g- (global) option to the regular expression. \"), mdx(\"p\", null, \"console.log(\\u201Chahehahehe\\u201D.replace(/a/, \\u201Ce\\u201D));\\n// \\u2192 hehehahehe\\nconsole.log(\\u201Chahehahehe\\u201D.replace(/a/g, \\u201Ce\\u201D));\\n// \\u2192 hehehehehe\"), mdx(\"p\", null, \"The above behavior of replacing all matches in a string can be replication using the replaceAll method, without having to use regular expressions at all. The advantage of using regular expressions with the -replace- method is that we can mention matched subexpression groups. For example, say we have two numbers 2 3 and we want to swap their positions to say 3 2 instead:\"), mdx(\"p\", null, \"console.log(\\u201C2 3\\u201D.replace(/(\\\\d+) (\\\\d+)/g, \\u201C$2 $1\\u201D));\\n// \\u2192 3 2\"), mdx(\"p\", null, \"In the above code, the groups (\\\\w+) and (\\\\w+) are associated with the characters $1 and $2 in the replacement string. $1 is replaced by the text matching the first group, $2 by the second group, and it goes on till $9. The entire match can be referenced with $&. \"), mdx(\"p\", null, \"Instead of a string, we may decide to pass a function as the second argument of the -replace- method. for every replacement, the function is called with the matched subexpression groups as arguments, then the value returned is added to the new string. The following code accepts a function as a second argument to replace, which converts specific strings to uppercase. \"), mdx(\"p\", null, \"let phrase = \\u201Cunicef is a humanitarian ngo.\\u201D;\\nlet re = phrase.replace(/\\\\b(unicef|ngo)\\\\b/g, word => word.toUpperCase())\\nconsole.log(re);\"), mdx(\"p\", null, \"When writing your code, you may not know the actual pattern you have to match against. Here, you can dynamically create RegExp objects. Suppose you want to look for a particular word in a sentence and surround it with quotation marks. This word will only be known during program execution, so it is better if we use the RegExp rather that the slash-based notation. \"), mdx(\"p\", null, \"let word = \\u201Chello\\u201D;\\nlet sentence = \\u201CMary says hello.\\u201D;\\nlet re = new RegExp(\\u201D\", \"\\\\\", \"b(\\u201D + word + \\u201C)\", \"\\\\\", \"b\\u201D, \\u201Ci\\u201D);\\nconsole.log(sentence.replace(re, \\u201D\\u2018$1\\u2019\\u201D));\\n// \\u2192 Mary says \\u2018hello\\u2019.\"), mdx(\"p\", null, \"Since we are writing the \\\\b boundary markers as a regular string, We use two backslashes when creating the \\\\b boundary marker in the RegExp constructor. The second argument given to the RegExp constructor holds the options for regular expression, which is \\u201Ci\\u201D for case insensitive in this example. \"), mdx(\"p\", null, \"The indexOf string method returns the position of a character or group of chracters in a string. \"), mdx(\"p\", null, \"console.log(\\u201Chello\\u201D.indexOf(\\u201Ce\\u201D));\\n// \\u2192 1\"), mdx(\"p\", null, \"indexOf does not accept regular expressions. In cases where we want to use regular expressions to determine the index of a character, we can use the -search- method. \"), mdx(\"p\", null, \"console.log(\\u201Cyear 2021\\u201D.search(/\\\\d/));\\n// \\u2192 5\"), mdx(\"p\", null, \"Regular expressions have properties, such as -source- (has the string that the expression was created from) and -lastIndex- (can sometimes control where the next index starts). \"), mdx(\"p\", null, \"We can use the lastIndex property with the exec method to start searching for a match from a specific position in the string. To do this, we must enable the global (-g-) or sticky (-y-) option in the regular expression. \"), mdx(\"p\", null, \"let re = /c/g;\\nre.lastIndex = 5;\\nlet match = re.exec(\\u201Cabcabcabc\\u201D);\\nconsole.log(match.index);\\n// \\u2192 5\\nconsole.log(re.lastIndex);\\n// \\u2192 6\"), mdx(\"p\", null, \"if there\\u2019s a successful match, the -exec- call will automatically update the lastIndex property, given it a value corresponding to the point after the match. If there is no match, lastIndex is treated like in a newly created RegExp opbject and it\\u2019s value is reverted to zero. \"), mdx(\"p\", null, \"Where enabled, the global option ensures that we begin searching for a position where a match starts ahead of the value of lastIndex. Whereas, when the sticky option is enabled, the match can only succeed if it begins directly at lastIndex. \"), mdx(\"p\", null, \"let globalOption = /456/g;\\nconsole.log(globalOption.exec(\\u201C123 456\\u201D));\\n// \\u2192 Array \", \"[ \\u201C456\\u201D ]\", \"\\nlet stickyOption = /456/y;\\nconsole.log(stickyOption.exec(\\u201C123 456\\u201D));\\n// \\u2192 null\"), mdx(\"p\", null, \"Problems can arise from automatic updates to lastIndex when we use the same regular expression value for several calls to -exec-. For example, it might cause a regular expression to start at an index left over from a previous -exec- call. \"), mdx(\"p\", null, \"let word = /ab/g;\\nconsole.log(word.exec(\\u201Ccccccab\\u201D));\\n// \\u2192 Array \", \"[ \\u201Cab\\u201D ]\", \"\\nconsole.log(word.exec(\\u201Ccab\\u201D));\\n// \\u2192 null\"), mdx(\"p\", null, \"The global option affects the way -match- works on strings. Using global, the -exec- method returns an array containing the first matched string, whereas the -match- method returns an array containing all matched strings. \"), mdx(\"p\", null, \"let re = /ah/g;\\nconsole.log(re.exec(\\u201Chahahahaha\\u201D));\\n// \\u2192  Array \", \"[ \\u201Cah\\u201D ]\", \"\\nconsole.log(\\u201Chahahahaha\\u201D.match(re));\\n// \\u2192 Array(4) \", \"[ \\u201Cah\\u201D, \\u201Cah\\u201D, \\u201Cah\\u201D, \\u201Cah\\u201D ]\"), mdx(\"p\", null, \"Global regular expressions are ideal when using the -replace- method and -lastIndex- property. Excercise caution when using global in other cicumstances, as it may have unintended side effects. \"), mdx(\"p\", null, \"Using the exec method and lastIndex, we can loop over matches. Here\\u2019s an example:\"), mdx(\"p\", null, \"let sentence = \\u201CI have 5 chickens, 5 dogs and 8 goats.\\u201D;\\nlet number = /\\\\b\\\\d+\\\\b/g;\\nlet foundNumbers;\\nwhile (foundNumbers = number.exec(sentence)){\\nconsole.log(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Found number ${foundNumbers[0]} at ${foundNumbers.index}\"), \");\\n// \\u2192  Found number 5 at 7\\n//    Found number 5 at 19\\n//    Found number 8 at 30\"), mdx(\"p\", null, \"In the code above, we use a while loop with condition foundNumbers = number.exec(sentence). This does the match at the start of each iteration of the loop, and then saves its result in a binding (foundNumbers, in this case). The loop stops when no more matches can be found. \"));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":{"id":"76933194-ff72-5f2d-be7e-2f91621aa82d","fields":{"slug":"/blog/how-information-transmitted/"},"frontmatter":{"title":"How information is transmitted on the internet"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How information is transmitted on the internet\",\n  \"date\": \"2021-11-11\",\n  \"categories\": [\"internet\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When devices communicate with each other on internet, such as through pictures, chat messages, etc, data is exchanged in the form of packets. A network packet is a piece of data that contains information about the message being sent, and the message itself. \"), mdx(\"p\", null, \"For example, to send an image to a friend over the internet, the picture is first fit into a packet, before being transferred. Since a photo is too big to fit into a single packet, it will be put into several packets. \"), mdx(\"p\", null, \"Internet protocols are responsible for deconstructing data and putting it into several packets. Each packet has a header, which contains the size of the packet, type of packet and an address tag having the origin and destination addresses. \"), mdx(\"p\", null, \"A packet consists of binary digits, that is, 0\\u2019s and 1\\u2019s. Binary data is the simplest representation of data that computers can process, since computers can only add and compare. Depending on the transmission medium, the network device decides how to encode the binary information before it is transmitted.\\nIf the transmission medium is copper wire, information is sent as electrical signals. If through glass fiber, it  If through air, it takes the form of radio waves. \"), mdx(\"p\", null, \"Packets are transmitted over a network as binary signals through frequency modulation. During this process, the transmitter translates binary data made up of 0s and 1s into a signals, and the receiver later translates these signals (electical, light, radio) back into 0s and 1s. \"), mdx(\"p\", null, \"To summarize, the full process is:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First, data is converted into packets. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Packets and encoded into binary data. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Binary data is converted into signals for transmission. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The receiver translates received signals into 0s and 1s. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"These 0s and 1s are converted back into the original information, such as an image, video or text chat. \")));\n}\n;\nMDXContent.isMDXComponent = true;"}}},
    "staticQueryHashes": ["3128451518"]}