{
    "componentChunkName": "component---src-templates-blog-post-js",
    "path": "/blog/bugs-errors-javascript/",
    "result": {"data":{"site":{"siteMetadata":{"title":"Enjeck's Personal Website","author":"Enjeck Cleopatra"}},"mdx":{"id":"343ec264-0555-56b5-aef6-91ce9394351c","excerpt":"A bug is a flaw or mistake in a computer program. Because JavaScript is quite loose, it often fails to catch typos when dealing with bindings and propertiesâ€¦","frontmatter":{"title":"How to debug JavaScript programs","date":"November 11, 2021"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How to debug JavaScript programs\",\n  \"date\": \"2021-11-11\",\n  \"categories\": [\"javascript\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A bug is a flaw or mistake in a computer program. Because JavaScript is quite loose, it often fails to catch typos when dealing with bindings and properties. JavaScript also allows silly computations without any warning, such as:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"false * \\\"hello\\\"\\n\")), mdx(\"p\", null, \"Multiplying a boolean value by a string should not work,  but JavaScript lets it happen without throwing an error. Computations like this will result in the special value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NaN\"), \" (not a number) or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \". Since it does not trigger an error message, you may end up passing this meaningless values through several functions, and not realizing the mistake until much later. \"), mdx(\"p\", null, \"JavaScript does complain when you write code that does not follow the language\\u2019s rules, call a statement that is not a function, or look up a property on an undefined value. \"), mdx(\"p\", null, \"Debugging is process of finding flaws or mistakes (bugs) in programs. Here are some ways to debug JavaScript programs:\"), mdx(\"h2\", null, \"Using strict mode\"), mdx(\"p\", null, \"To make JavaScript a bit stricter, you can enable strict mode by placing the string \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"use strict\\\"\"), \" at the top of a file or function body. \"), mdx(\"p\", null, \"Consider the following code, which runs without any issues:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let items = [1, 2, 3, 4];\\nfunction withoutLet() {\\n  for (item in items){\\n    console.log(`Number ${items[item]}`);\\n  }\\n}\\nwithoutLet();\\n// \\u2192 Number 1\\n// \\u2192 Number 2\\n// \\u2192 Number 3\\n// \\u2192 Number 4\\n\")), mdx(\"p\", null, \"Notice that above, we are able to use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"item\"), \" binding without defining it using the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let\"), \" keywords. \"), mdx(\"p\", null, \"Now, let\\u2019s add \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"\\\"use strict\\\"\"), \" inside the function body: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"let items = [1, 2, 3, 4];\\nfunction withoutLet() {\\n  \\\"use strict\\\";\\n  for (item in items){\\n    console.log(`Number ${items[item]}`);\\n  }\\n}\\nwithoutLet();\\n// \\u2192 ReferenceError: item is not defined\\n\")), mdx(\"p\", null, \"As shown in the first code example, when you don\\u2019t define \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"item\"), \" with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"var\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"const\"), \" keywords, JavaScript silently creates a global binding and uses it. When strict mode, shown in the second code snippet, is activated, JavaScript throws an error message. Note that if the binding in question already exists as a global binding, the loop will overwrite this global binding\\u2019s value. \"), mdx(\"p\", null, \"By default, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" binding refers to an object whose properties are the global bindings \\u2014 that is, a global scope object. In strict mode, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" has the value \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" in functions that are not called as methods. If you mistakenly call a constructor or method in strict mode, JavaScript will throw an error when it tries to read something from \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \", instead of writing to the global scope. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function Man(age) {\\n  this.age = age;\\n}\\nlet john = Man(23);\\nconsole.log(age);\\n// \\u2192 23\\n\")), mdx(\"p\", null, \"In the above code, since the constructor function is called without the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new\"), \" keyword, its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"this\"), \" will be written to the global scope, and will not refer to a newly constructor object.\"), mdx(\"p\", null, \"In strict mode, an error appears:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"\\\"use strict\\\";\\nfunction Man(age) {\\n  this.age = age;\\n}\\nlet john = Man(23);\\nconsole.log(age);\\n// \\u2192 TypeError: Cannot set property 'age' of undefined\\n\")), mdx(\"p\", null, \"In non-strict mode, we can avoid this error by using class notation. Constructors created with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"class\"), \" notation can be called without \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"new\"), \"  without any complains. \"), mdx(\"p\", null, \"Strict mode does other things like not allowing you to give a function multiple parameters with the same name and removing some problematic language features completely.\"), mdx(\"p\", null, \"Strict mode can help you debug issues with your code. \"), mdx(\"h2\", null, \"Types\"), mdx(\"p\", null, \"Some programming languages like Java and C require that you specify the data type of your bindings and expressions when defining them, and will notify you if you use a type incorrectly. For example, while you can create a JavaScript binding with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"let number = 45\"), \", you have to specify the data type in C, like so: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int number = 45\"), \". \"), mdx(\"p\", null, \"While some languages like C consider the data type before running the program, JavaScript only considers the type when running the program, then it tries to convert values to the type it expects so that it can do any computations. \"), mdx(\"p\", null, \"Many code mistakes arise from confusion about the type of value that goes in or out of a function. \"), mdx(\"p\", null, \"When you know the types of a program, you can get the computer to check them for you and point out mistakes before the program is run. JavaScript dialects, such as TypeScript, add types to the language and checks them, giving more rigor to yout programs. \"), mdx(\"h2\", null, \"Testing\"), mdx(\"p\", null, \"One way to find the mistakes in a program is to run the program and check whether it does the right thing. Doing this manually is quite painful, since it takes a lot of time to test everything every time you make a change. \"), mdx(\"p\", null, \"Automated testing is the practice of writing a program that can test another program without any manual involvement. Since computers are great at doing repetitive tasks and testing can get repetitive, there\\u2019s room to automate. The effort it takes to write tests is usually less than what it takes to manually test a program. With automated tests, you can ensure that a program behaves the way you want it to behave in seconds, even after changes. When something goes wrong, you\\u2019ll be notified immediately. \"), mdx(\"p\", null, \"Tests are simply small labeled programs that verify a piece of code. For example, below shows a set of tests for the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"toLowerCase\"), \" method. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function testMethod(label, body) {\\n  if (!body()) {\\n    console.log(`Test failed: ${label}`);\\n  }\\n}\\n\\ntestMethod(\\\"Convert Latin text to lowercase\\\", () => {\\n  return \\\"HEY\\\".toLowerCase() == \\\"hey\\\";\\n});\\n\\ntestMethod(\\\"Convert Russian text to lowercase\\\", () => {\\n  return \\\"\\u041F\\u0420\\u0418\\u0412\\u0415\\u0422\\\".toLowerCase() == \\\"\\u043F\\u0440\\u0438\\u0432\\u0435\\u0442\\\";\\n});\\n\\ntestMethod(\\\"Do not convert case-less text to lowercase\\\", () => {\\n  return \\\"\\u304A\\u3044\\\".toLowerCase() == \\\"\\u304A\\u3044\\\";\\n});\\n\")), mdx(\"p\", null, \"As you can see above, writing tests like this results in clunky repetitive code. We can use test runners, software that help with building and running test suites (sets of tests) by providing functions and methods to express tests and showing informative messages whenever a test fails. \"), mdx(\"p\", null, \"Some things are easier to test than others. It\\u2019s harder to test code that interacts with external objects, because it is tricky to figure out the context in which to test the code in. \"), mdx(\"h2\", null, \"Debugging\"), mdx(\"p\", null, \"Okay, so you know there\\u2019s a problem with your program. How do you know exactly what the problem is? At times, it is easy to see the problem, thanks to helpful error messages that reference a particular line of the program along with a description of the problem. Sometimes, it\\u2019s not so easy. The line that triggered the error may just a be starting point, and you may have to go through a rabbit hole to find the exact problem. \"), mdx(\"p\", null, \"For example, the following code should\\u2026\"), mdx(\"p\", null, \"To debug a program like this, avoid making random changes and hoping these changes fixes the code. Instead, analyse the code and think of what might be happening. \"), mdx(\"p\", null, \"In such situations, it helps to print out values are strategic parts of the program. This will give you more information about what the program is doing at certain points. \"), mdx(\"p\", null, \"Instead of using console.log, you may use the browser\\u2019s \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"debugger\"), \" features to look into the code\\u2019s behavior. Most browsers provide a way to set a breakpoint on a specific line of code, and during execution, the program pauses when it reaches a line with that breakpoint. The debugging capabilities vary across browsers. \"), mdx(\"p\", null, \"You can also set a breakpoint by including a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"debugger\"), \" statement in your code, and the browser will pause the program when in reaches that statement (assuming the developer tools of the browser are active). \"), mdx(\"h2\", null, \"Error propagation\"), mdx(\"p\", null, \"When something goes wrong in your program, it is nice for your program to do something in response to that problem. You may either want to continue running the program with the bogus input or stop the program after giving the user a report of what went wrong. \"), mdx(\"p\", null, \"Suppose you have a function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"upper\"), \" that asks the user for a word and returns the word in uppercase. If the user inputs a number, we can make the program return a special value such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"null\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \". \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function upper(promptText) {\\n  let word = String(prompt(promptText));\\n  if (Number(word)) return undefined;\\n  else return word.toUpperCase();\\n}\\nconsole.log(upper(\\\"Enter a word\\\"));\\n\")), mdx(\"p\", null, \"Whenever \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"upper\"), \" is called, it checks whether a number instead of a letter has been entered, in which case, it returns \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \". \"), mdx(\"p\", null, \"When a piece of code is prone to errors, it is a good practice to return a special value to indicate an error, as seen in the code example above. \"), mdx(\"p\", null, \"Returning special values has its downsides. For one, it can produce in clumsy code. For example, if a piece of code calls \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"upper\"), \" 100 times, it has to check 100 times whether \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"undefined\"), \" was returned. In addition, when a function can already return every possible kind of value, it is difficult to choose what special value should indicate an error. When dealing with such a function, you can bypass this roadblock by surrounding the result in an object to differentiate success from failure. \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"function firstItem(arr){\\n  if (arr.length == 0) {\\n    return {failed: true};\\n  }\\n  else {\\n    return {element: arr[0]}\\n  }\\n}\\n\\nfirstItem([2, 3, 5]);\\n// \\u2192 Object { element: 2 }\\n\\nfirstItem([]);\\n// \\u2192 Object { failed: true }\\n\")), mdx(\"h2\", null, \"Exceptions\"), mdx(\"p\", null, \"Another approach to dealing with bugs and errors in JavaScript is via exceptions. Exception handling is the mechanism where when a piece of code cannot proceed normally, it stops running and jumps to another piece of code that knows how to handle the problem. \"), mdx(\"p\", null, \"When code encounters a problem, we can make it to raise or throw an exception. An except can be any value you want it to be. Throwing an exception looks like returning a value from a function, except it \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"unwinds the stack\"), \". That is, it jumps out of the current function and its callers, right down to the initial function call that begun the current execution. \"), mdx(\"p\", null, \"Exceptions do not always unwind or zooms down the bottom of the stack. The power of exceptions lies in the ability to set \\u201Croadblocks\\u201D along the stack to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"catch\"), \" the exception as it unwinds. After catching an exception, you can address the problem and later continue to run the program.\"), mdx(\"p\", null, \"let x, result;\\nfunction numberOrNot(result){\\nif (!isNaN(result)) return \\u201CValid Number\\u201D;\\nthrow new Error(\\u201CNot a number: \\u201D + result);\\n}\"), mdx(\"p\", null, \"function check(x) {\\nif (!isNaN(numberOrNot(x)){\\nreturn \\u201CInput is a number\\u201D;\\n}\\nelse {\\nreturn \\u201CInput is a not number\\u201D;\\n}\\n}\"), mdx(\"p\", null, \"try {\\nconsole.log(check(x));\\n}\\ncatch (error) {\\nconsole.log(\\u201CInvalid value entered: \\u201D + error);\\n}\"), mdx(\"p\", null, \"check(\\u201Chey\\u201D);\\n// \\u2192 \\u201CInput is a string\\u201D\\ncheck(23);\\n// \\u2192 \\u201CInput is a number\\u201D\\ncheck([]);\\n// \\u2192 Invalid value entered: Error: Not a string or number: undefined\"), mdx(\"p\", null, \"We use the -throw- keyword to raise an exception, and catch an exception by surrounding a piece of code in a -try- block, followed by the -catch- keyword. If the code within the -try- block causes an exception to be thrown, the -catch- block is executed. The name in parentheses next to the -catch- block is associated to the exception value. Once the catch block finishes evaluation, or if the try block finishes without any issues, the program continues after the try/catch statement. \"), mdx(\"p\", null, \"In our code example, we used the -Error- contructor, which creates an object with a -message- property, to create our exception value. \"), mdx(\"p\", null, \"Some JavaScript environments keep a stack trace, which is information (gathered by the -Error- constructor) about the call stack that was available when the exception created. The stack trace is save in the -stack- property. It comes in handy when debugging problem, since it can inform us where the problem occurred and which functions made the failing function call. \"), mdx(\"p\", null, \"An advantage of exceptions is that the error-handling code is only useful at the position where the error happens and is handled, and any functions in between are almost free to ignore it. For example, our -check- function does not consider the possibility that the stringOrNumber function might go wrong. \"), mdx(\"p\", null, \"Any function call or property access might cause an exception, which in turn cause control to leave a piece of code. Control flow (or flow of control) is the order in which individual statements, instructions or function calls of a program are executed or evaluated. You might be more familiar with \\u201Cnormal\\u201D control flow statements like if-else statements and for loops. The effect produced by a exception is just another type of control flow. When code has multiple side effects, an except might stop some of these effects from occuring. \"), mdx(\"p\", null, \"The following code is for a terrible login system\"), mdx(\"p\", null, \"const users = {\\njohn: \\u2018john123\\u2019,\\nsarah: \\u2018sarah123\\u2019,\\njames: \\u2018james123\\u2019\\n};\"), mdx(\"p\", null, \"function checkUser(){\\nlet username = prompt(\\u201CEnter your username\\u201D);\\nif (!users.hasOwnProperty(username)){\\nthrow new Error(\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"User does not exist: ${username}\"), \")\\n}\\nreturn username;\\n}\\nfunction logIn(password){\\nconsole.log(\\u201CChecking if username and password match\\u2026\\u201D);\\nlet user = checkUser();\\nif (users\", \"[user]\", \" == password) return \\u201CPassword matches username. Welcome: \\u201D + user;\\nelse return \\u201CIncorrect password\\u201D;\\n}\"), mdx(\"p\", null, \"The logIn function checks if a provided username matches a with a password, and displays a welcome message if they match. If an invalid username is provided, checkUser raises an exception.\\nBut logIn first prints \\u201CChecking if username and password match\\u2026\\u201D before calling checkUser() to verify if the user exists. If it gets cut of by an exception at checkUser(), a match will not be checked (since we won\\u2019t reach the users\", \"[user]\", \" == password code), even though the previous statement says it is being done. Of course, the problem here can easily be fixed by moving or removing the statement. In some case, similar problems can happen is less noticeable ways. You may not think a function will throw an exception, but it might do so in certain cases, or when the code contains an error. \"), mdx(\"p\", null, \"We can handle similar issues by using fewer side effects. For example, it is preferable to create new data instead of editing existing data, so that if an exception causes a piece of code to stop running while creating a new value, no one will see the unfinished value, which is not a problem. \"), mdx(\"p\", null, \"It is sometimes impractical to reduce or remove side effects. Fortunately,  JavaScript provides the -finally- statement. In addition to or instead of the -catch- block, we can follow a -try- block with a finally- block. A -finally- block will ensure that the code within this -finally- block will be executed after that in the -try- block, no matter what happens. \"), mdx(\"p\", null, \"function logIn(password){\\nlet progress = 0;\\ntry {\\nconsole.log(\\u201CChecking if username and password match\\u2026\\u201D);\\nprogress = 1;\\nlet user = checkUser();\\nprogress = 2;\\nif (users\", \"[user]\", \" == password) return \\u201CPassword matches username. Welcome: \\u201D + user;\\n} finally {\\nif(progress == 1){\\nreturn \\u201CUsername and passowrd could not be checked\\u201D;\\n}\\n}\\n}\"), mdx(\"p\", null, \"This latest implementation of the logIn function monitors is progress, and if it sees that it was aborted at some point, it returns an another output. \"), mdx(\"p\", null, \"The -finally- code is executed even when an exception is raised in the -try- block, but it does not stand in the way of the exception. The stack will continue unwinding after the -finally- block finishes runing. \"), mdx(\"p\", null, \"Because creating programs that work well with exceptions is hard, many programmers do not bother with it, except in special conditions. It\\u2019s important to access what it will cost if the software fails, before deciding whether to invest time/effort addressing exceptions. \"), mdx(\"p\", null, \"Selective catching\"), mdx(\"p\", null, \"An exception may make it to the bottom of the stack without being caught. When this happens, the exception is handled by JavaScript environment, such as JavaScript console (available through the browser\\u2019s Tools or Developer menu) in browsers. Browsers usually write a descripton of the error to the console.\"), mdx(\"p\", null, \"Often, an unhandled exception indicates a problem with the program. The JavaScript console of browsers give some information about the exception, such as the function calls on the stack when the problem occurred. \"), mdx(\"p\", null, \"When programmer mistakes causes an exception to make it to the bottom of the stack without being caught, just ignoring the error is fine. But for problems that are expected to happen during program use, it is wise to handle exception. \"), mdx(\"p\", null, \"Exceptions will also be throws when JavaScript is used incorrectly, such as looking up a property on -undefined-, referencing a nonexistent binding, or calling a statement that is not a function. We can also catch such exceptions. \"), mdx(\"p\", null, \"When a program enters a -catch- body, we do not necessarily know what caused an exception or which exception it caused. All we know is that something in the -try- body caused an exception. \"), mdx(\"p\", null, \"JavaScript does not directly allow us to selectively catch exceptions. That is, you can\\u2019t choose to catch some and leave some. You must either catch all exceptions or don\\u2019t catch any. The exception you see is not necessarily the one you thought about while writing the -catch- block. It may be a whole other exception, or just a bug causing an exception. \"), mdx(\"p\", null, \"The following code \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"tries\"), \" to keep calling -numberOrNot- until it gets a valid number: \"), mdx(\"p\", null, \"function numberOrNot(){\\nlet result = prompt(\\u201CEnter an input\\u201D);\\nif (!isNaN(result)) return \\u201CValid Number\\u201D;\\nthrow new Error(\\u201CNot a number: \\u201D + result);\\n}\"), mdx(\"p\", null, \"for(;;){\\ntry {\\nlet w = numberOrNo(); // mispelled function call\\nconsole.log(\\u201CYou entered \\u201D, w);\\nbreak;\\n} catch (error) {\\nconsole.log(\\u201CNot a valid number. Try again.\\u201D);\\n}\\n}\"), mdx(\"p\", null, \"We use the -for (;;) construct to create a loop that can not terminate on its own. We only break out of this loop when a valid number is entered. Since we have a typo in the numberOrNot function call, this will result in an \\u201Cundefined variable\\u201D error. The -catch- block assumes it knows what the problem is and ignores its exception value -error- , which causes the binding error being incorrectly treated as a bad input error. This leads to an infinite loop, as well as the useful error message being \\u201Ccovered\\u201D by the mispelled binding. \"), mdx(\"p\", null, \"Unless you intend to \\u201Croute\\u201D an exception somewhere (for example, over a network to tell another program that our program has encountered an error or crashed), it is recommended not to blanket-catch exceptions as seen above. Always consider how you may be burying or hiding information with another. \"), mdx(\"p\", null, \"We can go about catching a specific type of exception by checking in the -catch- block if the exception we got is the exception we want, and if not, we rethrow it. One way we can check whether we got a specific exception is by comparing its -message- property against the error message we expect to occur. This approach is clumsy, as it involves using the message meant for human use to make a programmatic decision. If someone changes this message, the code won\\u2019t work any longer. It is better to use another method \\u2014 define a new type of error and use the -instanceof- operator to identify it. \"), mdx(\"p\", null, \"class NewError extends Error {}\"), mdx(\"p\", null, \"function numberOrNot() {\\nlet result = prompt(\\u201CEnter an input\\u201D);\\nif (!isNaN(result)) return \\u201CValid Number\\u201D;\\nthrow new Error(\\u201CNot a number: \\u201D + result);\\n}\"), mdx(\"p\", null, \"The new error class, NewError, extends Error. It is left empty and does not defined anything. Since it does not define its own constructor, it inherits the -Error- constructor, which expects a message (string) as argument. A NewError object acts like -Error- object, with the exception of a different class by which to identify them. \"), mdx(\"p\", null, \"We can now rewrite the previous loop to catch error more carefully:\"), mdx(\"p\", null, \"class NewError extends Error {}\"), mdx(\"p\", null, \"function numberOrNot() {\\nlet result = prompt(\\u201CEnter an input\\u201D);\\nif (!isNaN(result)) return \\u201CValid Number\\u201D;\\nthrow new Error(\\u201CNot a number: \\u201D + result);\\n}\"), mdx(\"p\", null, \"for (;;) {\\ntry {\\nlet w = numberOrNot();\\nconsole.log(\\u201CYou entered \\u201D, w);\\nbreak;\\n} catch (error) {\\nif (error instanceof NewError) {\\nconsole.log(\\u201CNot a valid number. Try again.\\u201D);\\n} else {\\nthrow error;\\n}\\n}\\n}\"), mdx(\"p\", null, \"This for statement will now only catch instances of -NewError- and ignores unrelated exceptions. If we misspell the function call as before, the undefined binding error will be correctly reported (Uncaught ReferenceError: numberOrNo is not defined).\"), mdx(\"p\", null, \"An assertion is a check in a piece of code that verifies that somethng is the way is it supposed to be. Assertions are used to find programmer mistakes, not for \\u201Cregular\\u201D errors. \"), mdx(\"p\", null, \"For example, we can ensure that the -lastElement0 function below should never be called on empty arrays, like so:\"), mdx(\"p\", null, \"function lastElement(arr) {\\nif (arr.length == 0) {\\nthrow new Error(\\u201ClastElement called with empty array, []\\u201D);\\n}\\nreturn arr\", \"[arr.length - 1]\", \";\\n}\"), mdx(\"p\", null, \"lastElement(\", \"[3, 5, 7]\", \");\\n// \\u2192  7\\nlastElement([]);\\n// \\u2192  Uncaught Error: lastElement called with empty array, []\"), mdx(\"p\", null, \"If we did not catch the error, trying to get the last element of an empty array will return undefined, which is the value gotten when you read a nonexistent array property). Our code ensures that an empty array is not used, by throwing an error in such circumstances. This ensures that such mistakes are noticed and easier to debug. \"), mdx(\"p\", null, \"Writing assertions for every likely type of bad input is not a good practice, since it is time-consuming and produces noisy code. Assertions are ideal for mistakes that are easy to make. \"), mdx(\"p\", null, \"Conclusion\"), mdx(\"p\", null, \"Mistakes happen. So do bad input. It is important to know how to find, diagnose and fix bugs. Automated test suites and assertions make it easier to notice and problems. \"), mdx(\"p\", null, \"When problems are caused by factors outside a program\\u2019s control, they can be handled locally by tracking them using special values, or using exception. \"), mdx(\"p\", null, \"When an exception is raised, the call stack unwinds until the next enclosing try/catch block or until it reaches the bottom of the stack. The exception value given to the -catch- block that catches the exception should be used to verify if it is the expected kind of exception and how to address it. The -finally- block can be used to \\u201Csmooth\\u201D the unpredictiable control flow effect of exceptions by ensuring that a peice of code will always run after the -try- block finishes. \"));\n}\n;\nMDXContent.isMDXComponent = true;"}},"pageContext":{"slug":"/blog/bugs-errors-javascript/","previous":{"id":"76933194-ff72-5f2d-be7e-2f91621aa82d","fields":{"slug":"/blog/how-information-transmitted/"},"frontmatter":{"title":"How information is transmitted on the internet"},"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"How information is transmitted on the internet\",\n  \"date\": \"2021-11-11\",\n  \"categories\": [\"internet\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"When devices communicate with each other on internet, such as through pictures, chat messages, etc, data is exchanged in the form of packets. A network packet is a piece of data that contains information about the message being sent, and the message itself. \"), mdx(\"p\", null, \"For example, to send an image to a friend over the internet, the picture is first fit into a packet, before being transferred. Since a photo is too big to fit into a single packet, it will be put into several packets. \"), mdx(\"p\", null, \"Internet protocols are responsible for deconstructing data and putting it into several packets. Each packet has a header, which contains the size of the packet, type of packet and an address tag having the origin and destination addresses. \"), mdx(\"p\", null, \"A packet consists of binary digits, that is, 0\\u2019s and 1\\u2019s. Binary data is the simplest representation of data that computers can process, since computers can only add and compare. Depending on the transmission medium, the network device decides how to encode the binary information before it is transmitted.\\nIf the transmission medium is copper wire, information is sent as electrical signals. If through glass fiber, it  If through air, it takes the form of radio waves. \"), mdx(\"p\", null, \"Packets are transmitted over a network as binary signals through frequency modulation. During this process, the transmitter translates binary data made up of 0s and 1s into a signals, and the receiver later translates these signals (electical, light, radio) back into 0s and 1s. \"), mdx(\"p\", null, \"To summarize, the full process is:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"First, data is converted into packets. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Packets and encoded into binary data. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Binary data is converted into signals for transmission. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"The receiver translates received signals into 0s and 1s. \"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"These 0s and 1s are converted back into the original information, such as an image, video or text chat. \")));\n}\n;\nMDXContent.isMDXComponent = true;"},"next":null}},
    "staticQueryHashes": ["3128451518"]}